package org.ncgr.pangenomics.genotype;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;

import java.util.Arrays;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
import java.util.Optional;
import java.util.TreeMap;
import java.util.Set;
import java.util.HashSet;
import java.util.TreeSet;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

import org.jgrapht.graph.DirectedAcyclicGraph;

import org.mskcc.cbio.portal.stats.FisherExact;

public class PangenomicGraph extends DirectedAcyclicGraph<Node,Edge> {

    // a name for this graph
    public String name;

    // Map of Node.id to Node
    public TreeMap<Long,Node> nodeIdMap = new TreeMap<>();

    // this graph's paths
    public TreeSet<Path> paths = new TreeSet<>();

    // maps a label to a count of paths that have that label
    public TreeMap<String,Integer> labelCounts = new TreeMap<>();

    // instantiated once to save time and for use elsewhere
    public FisherExact fisherExact;

    // this graph's samples
    protected TreeSet<Sample> samples = new TreeSet<>();
    
    // Map of path.getName() to the Path
    protected TreeMap<String,Path> pathNameMap = new TreeMap<>();

    // Map of Node.getKey() to Node (optional)
    protected TreeMap<String,Node> nodeKeyMap = new TreeMap<>();

    // maps a Node to the Paths that traverse it
    protected TreeMap<Node,List<Path>> nodePathMap = new TreeMap<>();

    // output verbosity
    protected boolean verbose;

    /**
     * Basic constructor.
     */
    public PangenomicGraph(String name) {
        super(Edge.class);
	this.name = name;
    }

    /**
     * Build this graph's paths from Maps generated by an Importer and filters.
     */
    public void buildGraphPaths(TreeMap<Sample,NodeSet> sampleNodeSets, TreeMap<Node,TreeSet<Sample>> nodeSamples, int maxCases, boolean equalizeCasesControls) {
	// load instance samples from the sampleNodeSets
	samples = new TreeSet<>(sampleNodeSets.keySet());
	// FILTER: limit maximum cases
	if (maxCases>0) {
	    int nCases = 0;
	    int nControls = 0;
            for (Sample sample : samples) {
                if (sample.isCase()) {
                    nCases++;
                } else if (sample.isControl()) {
                    nControls++;
                }
            }
            Set<Sample> samplesToDrop = new HashSet<>();
            int numberToRemove = nCases - maxCases;
	    int count = 0;
	    // randomly select samples to drop
	    while (count<numberToRemove) {
		Optional<Sample> optional = samples.stream().skip((int)(samples.size()*Math.random())).findFirst();
		if (optional.isPresent()) {
		    Sample sample = optional.get();
		    if (count<numberToRemove && sample.isCase() && !samplesToDrop.contains(sample)) {
			samplesToDrop.add(sample);
			count++;
		    }
                }
	    }
	    // remove dropped samples
	    for (Sample sample : samplesToDrop) {
		samples.remove(sample);
		sampleNodeSets.remove(sample);
		for (Node n : nodeSamples.keySet()) {
		    Set<Sample> samples = nodeSamples.get(n);
		    samples.remove(sample);
		}
            }
            // drop nodes that no longer have any samples
            Set<Node> nodesToDrop = new HashSet<>();
            for (Node n : nodeSamples.keySet()) {
                Set<Sample> samples = nodeSamples.get(n);
                if (samples.size()==0) nodesToDrop.add(n);
            }
	    for (Node n : nodesToDrop) {
		nodeIdMap.remove(n.id);
		nodeSamples.remove(n);
	    }
            System.err.println("Removed "+samplesToDrop.size()+" samples and "+nodesToDrop.size()+" orphaned nodes to set number of cases = "+maxCases+".");
	}
	// FILTER: enforce cases=controls
        if (equalizeCasesControls) {
            int nCases = 0;
            int nControls = 0;
            for (Sample sample : samples) {
                if (sample.isCase()) {
                    nCases++;
                } else if (sample.isControl()) {
                    nControls++;
                }
            }
            Set<Sample> samplesToDrop = new HashSet<>();
            int numberToRemove = Math.abs(nCases - nControls);
            int count = 0;
            // randomly select samples to drop
            while (count<numberToRemove) {
                Optional<Sample> optional = samples.stream().skip((int)(samples.size()*Math.random())).findFirst();
                if (optional.isPresent()) {
                    Sample sample = optional.get();
                    if (nCases>nControls && sample.isCase() && !samplesToDrop.contains(sample)) {
                        samplesToDrop.add(sample);
                        count++;
                    } else if (nControls>nCases && sample.isControl() && !samplesToDrop.contains(sample)) {
                        samplesToDrop.add(sample);
                        count++;
                    }
                }
	    }
	    // remove dropped samples
	    for (Sample sample : samplesToDrop) {
		samples.remove(sample);
		sampleNodeSets.remove(sample);
		for (Node n : nodeSamples.keySet()) {
		    Set<Sample> samples = nodeSamples.get(n);
		    samples.remove(sample);
		}
            }
            // drop nodes that no longer have any samples
            Set<Node> nodesToDrop = new HashSet<>();
            for (Node n : nodeSamples.keySet()) {
                Set<Sample> samples = nodeSamples.get(n);
                if (samples.size()==0) nodesToDrop.add(n);
            }
	    for (Node n : nodesToDrop) {
		nodeIdMap.remove(n.id);
		nodeSamples.remove(n);
	    }
            System.err.println("Removed "+samplesToDrop.size()+" samples and "+nodesToDrop.size()+" orphaned nodes to equalize cases and controls.");
        }
        // build the paths and path-labeled graph edges from the samples and sampleNodeSets map
        if (verbose) System.err.println("Creating paths and adding edges to graph...");
        for (Sample sample : samples) {
	    if (sampleNodeSets.containsKey(sample)) {
		NodeSet sampleNodes = sampleNodeSets.get(sample);
		Path path = new Path(this, new LinkedList<Node>(sampleNodes), sample);
		paths.add(path);
		pathNameMap.put(sample.name, path);
		// add edges
		Node lastNode = null;
		for (Node sampleNode : sampleNodes) {
		    // sampleNode only contains id -- get actual node from graph for this id
		    Node node = getNode(sampleNode.id);
		    if (node==null) {
			System.err.println("ERROR: graph node missing for sample "+sample.name+" node "+sampleNode.id);
			System.exit(1);
		    }
		    if (lastNode!=null) {
			if (!containsEdge(lastNode, node)) {
			    try {
				addEdge(lastNode, node);
			    } catch (Exception e) {
				System.err.println(e);
				System.err.println("ERROR adding edge from "+lastNode+" to "+node);
				System.exit(1);
			    }
			}
		    }
		    lastNode = node;
		}
	    }
        }
	// initialize FisherExact for later use
        fisherExact = new FisherExact(paths.size());
    }
    
    /**
     * Build this graph from the provided Nodes and Paths.
     */
    public void buildGraph(TreeMap<Long,Node> nodes, TreeSet<Path> paths) {
        this.paths = paths;
        // add the nodes as graph vertices
        if (verbose) System.err.println("Adding nodes to graph vertices...");
        for (Node n : nodes.values()) {
            addVertex(n);
        }
        // build the path-labeled graph edges
        if (verbose) System.err.println("Adding edges to graph from paths...");
        for (Path path : paths) {
            pathNameMap.put(path.getName(), path);
            // add edges
            Node lastNode = null;
            for (Object n : path.getNodes()) {
                Node node = (Node) n;
                if (lastNode!=null) {
                    if (!containsEdge(lastNode, node)) {
                        try {
                            addEdge(lastNode, node);
                        } catch (Exception e) {
                            System.err.println("ERROR adding edge from "+lastNode+" to "+node);
                            System.err.println(e);
                            System.exit(1);
                        }
                    }
                }
                lastNode = node;
            }
        }
        fisherExact = new FisherExact(paths.size());
    }
    
    /**
     * Build this graph's nodes from the given nodeIdMap.
     */
    public void buildGraphNodes(TreeMap<Long,Node> nodeIdMap) {
	// we need nodeIdMap for other things
	this.nodeIdMap = nodeIdMap;
	checkNodeIdMap();
        // add the nodes as graph vertices
        for (Node n : nodeIdMap.values()) {
            addVertex(n);
	}
    }

    /**
     * Build this graph's nodes from the given nodeIdMap, also setting nodeKeyMap.
     */
    public void buildGraphNodes(TreeMap<Long,Node> nodeIdMap, TreeMap<String,Node> nodeKeyMap) {
	// we need nodeIdMap for other things
	this.nodeIdMap = nodeIdMap;
	this.nodeKeyMap = nodeKeyMap;
	checkNodeIdMap();
	checkNodeKeyMap();
        // add the nodes as graph vertices
        for (Node n : nodeIdMap.values()) {
            addVertex(n);
	}
    }

    /**
     * Build this graph's nodeKeyMap.
     */
    protected void buildNodeKeyMap(TreeMap<Long,Node> nodeIdMap) {
	for (Node n : nodeIdMap.values()) {
	    nodeKeyMap.put(n.getKey(), n);
	}
    }

    /**
     * Tally the label counts for the paths in this graph (can be a subset of all samples/paths).
     */
    public void tallyLabelCounts() {
	// clear just in case
	for (String label : labelCounts.keySet()) {
	    labelCounts.put(label, 0);
	}
        for (Path path : paths) {
            if (labelCounts.containsKey(path.getLabel())) {
                int count = labelCounts.get(path.getLabel());
                labelCounts.put(path.getLabel(), count+1);
            } else {
                labelCounts.put(path.getLabel(), 1);
            }
        }
    }

    /**
     * Build the node paths: the set of paths that run through each node.
     */
    public void buildNodePaths() {
	if (verbose) System.err.println("Building node paths...");
        // initialize empty paths for each node
        for (Node n : getNodes()) {
            nodePathMap.put(n, new LinkedList<Path>());
        }
        // now load the paths
	for (Path path : paths) {
	    List<Node> pathNodes = path.getNodes();
	    for (Node n : pathNodes) {
		nodePathMap.get(n).add(path);
	    }
	}
	// validation
	for (Node n : nodePathMap.keySet()) {
	    List<Path> pathList = nodePathMap.get(n);
	    for (Path p : pathList) {
		if (p==null) {
		    System.err.println("ERROR: p==null for node "+n.toString());
		    System.exit(1);
		}
	    }
	}
    }

    /**
     * Return the node paths, building them first if needed.
     */
    public TreeMap<Node,List<Path>> getNodePaths() {
	if (nodePathMap.size()==0) buildNodePaths();
	return nodePathMap;
    }

    /**
     * Return the node with the given id, else null.
     */
    public Node getNode(long id) {
        return nodeIdMap.get(id);
    }

    /**
     * Return true if this graph contains the path with the given name.
     */
    public boolean hasPath(String name) {
        return pathNameMap.containsKey(name);
    }
    
    /**
     * Return the path with the given name.
     */
    public Path getPath(String name) {
        return pathNameMap.get(name);
    }

    /**
     * Return the number of this graph's paths.
     */
    public int getPathCount() {
        return paths.size();
    }

    /**
     * Get the count of paths with the given label.
     */
    public int getPathCount(String label) {
        if (labelCounts.containsKey(label)) {
            return labelCounts.get(label);
        } else {
            return 0;
        }
    }

    /**
     * Return the number of paths that traverse the given node.
     */
    public int getPathCount(Node n) {
        return getPaths(n).size();
    }

    /**
     * Get the total count of paths that follow the given Edge.
     */
    public int getPathCount(Edge e) {
        int count = 0;
        for (Path p : paths) {
            List<Edge> edges = p.getEdges();
            if (edges.contains(e)) {
                count++;
            }
        }
        return count;
    }

    /**
     * Get the count of paths with the given label that follow the given Edge.
     */
    public int getPathCount(Edge e, String label) {
        int count = 0;
        for (Path p : paths) {
            if (p.getLabel().equals(label)) {
                List<Edge> edges = p.getEdges();
                if (edges.contains(e)) {
                    count++;
                }
            }
        }
        return count;
    }

    /**
     * Return the paths that traverse the given node.
     */
    public List<Path> getPaths(Node n) {
        return getNodePaths().get(n);
    }

    /**
     * Just a synonym for vertexSet(), but puts the Nodes in a List.
     */
    public List<Node> getNodes() {
        return new LinkedList<Node>(vertexSet());
    }

    /**
     * Construct a NodeSet from a string representation, e.g. [1350,1352,1353,1465,1467,1468,1469].
     */
    public NodeSet getNodeSet(String str) {
        NodeSet nodeSet = new NodeSet();
        List<Node> allNodes = getNodes();
        Map<Long,Node> allNodeMap = new HashMap<>();
        for (Node n : allNodes) allNodeMap.put(n.id, n);
        List<String> nodeStrings = Arrays.asList(str.replace("[","").replace("]","").split(","));
        for (String s : nodeStrings) {
            if (s.length()>0) {
                long id = Long.parseLong(s);
                if (allNodeMap.containsKey(id)) {
                    nodeSet.add(allNodeMap.get(id));
                } else {
                    // bail, we're asked for a node that is not in the graph
		    System.err.println("ERROR: Graph does not contain node "+id);
		    System.exit(1);
		}
            }
        }
        return nodeSet;
    }

    /**
     * Get the label counts map for paths that traverse the given node.
     */
    public Map<String,Integer> getLabelCounts(Node n) {
        Map<String,Integer> map = new HashMap<>();
        for (Path p : getNodePaths().get(n)) {
            if (map.containsKey(p.getLabel())) {
                // increment count
                int count = map.get(p.getLabel()) + 1;
                map.put(p.getLabel(), count);
            } else {
                // initialize count
                map.put(p.getLabel(), 1);
            }
        }
        return map;
    }

    /**
     * Get the label counts for paths that follow the given Edge.
     * TODO: restrict path loop to those that are on Nodes connected by Edge. May not be worth it.
     */
    public Map<String,Integer> getLabelCounts(Edge e) {
        Map<String,Integer> map = new HashMap<>();
        for (Path p : paths) {
            List<Edge> edges = p.getEdges();
            if (edges.contains(e)) {
                if (map.containsKey(p.getLabel())) {
                    // increment count
                    int count = map.get(p.getLabel()) + 1;
                    map.put(p.getLabel(), count);
                } else {
                    // initialize count
                    map.put(p.getLabel(), 1);
                }
            }
        }
        return map;
    }

    /**
     * Return the path names as a string array.
     */
    public String[] getPathNames() {
        String[] names = new String[paths.size()];
	int i = 0;
	for (Path p : paths) {
	    names[i++] = p.getName();
	}
        return names;
    }

    /**
     * Return the odds ratio for case/control paths that traverse the given node vs. case/control paths that don't.
     * 0                 = all control paths traverse node
     * POSITIVE_INFINITY = all case paths traverse node
     */
    public double oddsRatio(Node n) {
        Map<String,Integer> countsMap = getLabelCounts(n);
        int nodeCasePaths = 0; if (countsMap.containsKey("case")) nodeCasePaths = countsMap.get("case");
        int nodeCtrlPaths = 0; if (countsMap.containsKey("ctrl")) nodeCtrlPaths = countsMap.get("ctrl");
        int otherCasePaths = labelCounts.get("case") - nodeCasePaths;
        int otherCtrlPaths = labelCounts.get("ctrl") - nodeCtrlPaths;
        return (double)(nodeCasePaths*otherCtrlPaths) / (double)(nodeCtrlPaths*otherCasePaths);
    }

    /**
     * Return the Fisher's exact test two-tailed p value for case/control paths that traverse the given node
     * vs. case/control paths that don't.
     *
     *      | traverse node | don't trv node |
     *      |--------------------------------|
     * case | nodeCasePaths | otherCasePaths |
     * ctrl | nodeCtrlPaths | otherCtrlPaths |
     */
    public double fisherExactP(Node n) {
        Map<String,Integer> countsMap = getLabelCounts(n);
        int nodeCasePaths = 0; if (countsMap.containsKey("case")) nodeCasePaths = countsMap.get("case");
        int nodeCtrlPaths = 0; if (countsMap.containsKey("ctrl")) nodeCtrlPaths = countsMap.get("ctrl");
        int otherCasePaths = labelCounts.get("case") - nodeCasePaths;
        int otherCtrlPaths = labelCounts.get("ctrl") - nodeCtrlPaths;
        return fisherExact.getTwoTailedP(nodeCasePaths, otherCasePaths, nodeCtrlPaths, otherCtrlPaths);
    }

    /**
     * Print out the nodes
     * public long id;
     * public String rs;
     * public String contig;
     * public int start;
     * public int end;
     * public String genotype;
     */
    public void printNodes(PrintStream out) {
        if (out==System.out) printHeading("NODES");
        for (Node n : getNodes()) {
            out.println(n.id+"\t"+n.rs+"\t"+n.contig+"\t"+n.start+"\t"+n.end+"\t"+n.genotype+"\t"+n.gf);
        }
    }

    /**
     * Print the paths, labeled by path.getName().
     */
    public void printPaths(PrintStream out) {
        if (out==System.out) printHeading("PATHS");
        for (Path path : paths) {
	    out.println(path.toString());
        }
    }

    /**
     * Print a delineating heading, for general use.
     */
    static void printHeading(String heading) {
        for (int i=0; i<heading.length(); i++) System.out.print("="); System.out.println("");
        System.out.println(heading);
        for (int i=0; i<heading.length(); i++) System.out.print("="); System.out.println("");
    }

    /**
     * Load the graph nodes from a nodes.txt file without filtering.
     */
    public void loadNodesFromTXT(File nodesFile) throws IOException {
        TXTImporter importer = new TXTImporter(nodesFile);
	importer.setVerbose(verbose);
        importer.readNodes();
	buildGraphNodes(importer.nodeIdMap);
	buildNodeKeyMap(importer.nodeIdMap);
    }

    /**
     * Append nodes from a nodes.txt file to the current graph without filtering.
     */
    public void appendNodesFromTXT(File nodesFile) throws IOException {
	// get last ID of current graph nodes
	long lastId = nodeIdMap.lastKey();
	// load the nodes
        TXTImporter importer = new TXTImporter(nodesFile);
	importer.setVerbose(verbose);
        importer.readNodes();
        // add the nodes as graph vertices, incrementing nodeId each time
        for (Node n : importer.nodeIdMap.values()) {
	    lastId++;
	    n.id = lastId;
            addVertex(n);
	    nodeIdMap.put(lastId, n);
	}
	// rebuild the node key map
	buildNodeKeyMap(nodeIdMap);
    }

    /**
     * Load the graph paths from a paths.txt file without any constraints.
     */
    public void loadPathsFromTXT(File pathsFile) throws IOException {
	loadPathsFromTXT(pathsFile, 0, false);
    }

    /**
     * Load all graph paths from a paths.txt file with the given constraints.
     */
    public void loadPathsFromTXT(File pathsFile, int maxCases, boolean equalizeCasesControls) throws IOException {
	checkNodeIdMap();
        TXTImporter importer = new TXTImporter(pathsFile, nodeIdMap);
	importer.setVerbose(verbose);
        importer.readPaths();
	buildGraphPaths(importer.sampleNodeSets, importer.nodeSamples, maxCases, equalizeCasesControls);
    }

    /**
     * Load graph paths for the given samples in labels.txt from a paths.txt file with the given constraints.
     */
    public void loadPathsFromTXT(File pathsFile, File labelsFile, int maxCases, boolean equalizeCasesControls) throws IOException {
	checkNodeIdMap();
        TXTImporter importer = new TXTImporter(pathsFile, nodeIdMap);
	importer.setVerbose(verbose);
        importer.readPaths(labelsFile);
        buildGraphPaths(importer.sampleNodeSets, importer.nodeSamples, maxCases, equalizeCasesControls);
    }

    /**
     * Load the graph nodes from a VCF file.
     */
    public void loadNodesFromVCF(File vcfFile, double minMAF, double maxMAF) throws IOException {
        VCFImporter importer = new VCFImporter(vcfFile);
	importer.setVerbose(verbose);
	if (minMAF>0.0 || maxMAF<1.0) {
	    importer.readNodes(minMAF, maxMAF);
	} else {
	    importer.readNodes();
	}
	buildGraphNodes(importer.nodeIdMap, importer.nodeKeyMap);
    }

    /**
     * Load the graph nodes and paths from a VCF file and labels file.
     */
    public void loadPathsFromVCF(File vcfFile, File labelsFile, int maxCases, boolean equalizeCasesControls) throws IOException {
	checkNodeIdMap();
	checkNodeKeyMap();
        VCFImporter importer = new VCFImporter(vcfFile, nodeIdMap, nodeKeyMap);
	importer.setVerbose(verbose);
        importer.readPaths(labelsFile);
	buildGraphPaths(importer.sampleNodeSets, importer.nodeSamples, maxCases, equalizeCasesControls);
    }

    /**
     * Load the graph nodes from a PLINK list output file for nodes within the given MGF range.
     * TODO: add filtering!
     */
    public void loadNodesFromList(File listFile, double minMGF, double maxMGF) throws IOException {
        ListImporter importer = new ListImporter(listFile);
	importer.setVerbose(verbose);
	if (minMGF>0.0 || maxMGF<1.0) {
	    importer.readNodes(minMGF, maxMGF);
	} else {
	    importer.readNodes();
	}
        buildGraphNodes(importer.nodeIdMap, importer.nodeKeyMap);
    }

    /**
     * Load the graph paths from a PLINK list output file and labels file for nodew in the given MGF range.
     */
    public void loadPathsFromList(File listFile, File labelsFile, int maxCases, boolean equalizeCasesControls) throws IOException {
	checkNodeIdMap();
	checkNodeKeyMap();
	ListImporter importer = new ListImporter(listFile, nodeIdMap, nodeKeyMap);
	importer.setVerbose(verbose);
	importer.readPaths(labelsFile);
	buildGraphPaths(importer.sampleNodeSets, importer.nodeSamples, maxCases, equalizeCasesControls);
    }

    /**
     * The main event.
     */
    public static void main(String[] args) throws IOException, FileNotFoundException {
	Options options = new Options();
        CommandLineParser parser = new DefaultParser();
        HelpFormatter formatter = new HelpFormatter();
        CommandLine cmd;

        Option verboseOption = new Option("v", "verbose", false, "verbose output (false)");
        verboseOption.setRequired(false);
        options.addOption(verboseOption);
        // REQUIRED: graph name
        Option graphOption = new Option("g", "graph", true, "name of graph (required)");
        graphOption.setRequired(true);
        options.addOption(graphOption);
	// ACTION: build graph nodes
	Option nodesOption = new Option("n", "buildnodes", false, "build graph nodes (this or --buildpaths required)");
	nodesOption.setRequired(false);
	options.addOption(nodesOption);
	// ACTION: concatenate graphs
	Option catOption = new Option("c", "cat", false, "concatenate two graphs (--nodes and --nodes2 requried)");
	catOption.setRequired(false);
	options.addOption(catOption);
	// ACTION: build graph paths
	Option pathsOption = new Option("p", "buildpaths", false, "build graph paths (this or --buildnodes required)");
	pathsOption.setRequired(false);
	options.addOption(pathsOption);
        // INPUT: VCF file
        Option vcfFileOption = new Option("vcf", "vcffile", true, "build graph nodes/paths from a tabix-indexed gzipped VCF file");
        vcfFileOption.setRequired(false);
        options.addOption(vcfFileOption);
	// INPUT: PLINK -list file
	Option listFileOption = new Option("list", "listfile", true, "build graph nodes/paths from a PLINK list file");
	listFileOption.setRequired(false);
	options.addOption(listFileOption);
	// INPUT: nodes.txt
	Option nodesFileOption = new Option("nodes", "nodesfile", true, "read graph nodes from a nodes.txt file");
	nodesFileOption.setRequired(false);
	options.addOption(nodesFileOption);
	// INPUT: second nodes.txt
	Option nodes2FileOption = new Option("nodes2", "nodes2file", true, "read a second graph nodes from a nodes.txt file");
	nodes2FileOption.setRequired(false);
	options.addOption(nodes2FileOption);
        // INPUT: paths.txt 
        Option pathsFileOption = new Option("paths", "pathsfile", true, "read graph paths from a paths.txt file");
        pathsFileOption.setRequired(false);
        options.addOption(pathsFileOption);
	// INPUT: labels.txt
        Option labelsFileOption = new Option("l", "labelsfile", true, "tab-delimited file containing one sample<tab>label pair per line for desired paths");
        labelsFileOption.setRequired(false);
        options.addOption(labelsFileOption);
        // FILTER: reduce cases or controls so they are equal in number
        Option equalizeCasesControlsOption = new Option("ecc", "equalizecasescontrols", false, "reduce cases or controls to make equal in number [false]");
        equalizeCasesControlsOption.setRequired(false);
        options.addOption(equalizeCasesControlsOption);
	// FILTER: set max case paths
	Option maxCasesOption = new Option("maxc", "maxcases", true, "maxiumum number of case paths in the graph [no limit]");
	maxCasesOption.setRequired(false);
	options.addOption(maxCasesOption);
	// FILTER: minMAF
	Option minMAFOption = new Option("minmaf", "minmaf", true, "minimum MAF/MGF of loci to be included on graph in percent [0]");
	minMAFOption.setRequired(false);
	options.addOption(minMAFOption);
	// FILTER: maxMAF
	Option maxMAFOption = new Option("maxmaf", "maxmaf", true, "maximum MAF/MGF of loci to be included on graph in percent [100.00]");
	maxMAFOption.setRequired(false);
	options.addOption(maxMAFOption);
	
        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e) {
            System.err.println(e.getMessage());
            formatter.printHelp("PangenomicGraph", options);
            System.exit(1);
            return;
        }

        // spit out help and exit if nothing supplied
        if (cmd.getOptions().length==0) {
            formatter.printHelp("PangenomicGraph", options);
            System.exit(1);
            return;
        }

	// check that we have a requested action
	if (!cmd.hasOption("buildnodes") && !cmd.hasOption("buildpaths") && !cmd.hasOption("cat")) {
	    System.err.println("ERROR: you must request building graph nodes (--nodes) or building graph paths (--paths) or concatenating two graphs (--cat)");
	    System.exit(1);
	}
	boolean buildNodes = cmd.hasOption("buildnodes");
	boolean buildPaths = cmd.hasOption("buildpaths");
	boolean catGraphs = cmd.hasOption("cat");
	
        // validation
        boolean haveVCF = cmd.hasOption("vcffile");
	boolean haveList = cmd.hasOption("listfile");
	boolean haveNodes = cmd.hasOption("nodesfile");
	boolean haveNodes2 = cmd.hasOption("nodes2file");
	boolean havePaths = cmd.hasOption("pathsfile");
	boolean haveLabels = cmd.hasOption("labelsfile");
	if (buildNodes && !haveVCF && !haveList && !haveNodes) {
	    System.err.println("ERROR: to build a graph you must specify an input file with -vcf, -list, or -nodes");
	    System.exit(1);
	}
	if (buildPaths && !haveVCF && !haveList && !haveNodes) {
	    System.err.println("ERROR: to build graph paths you must specify an input file with -vcf, -list, or -nodes");
	    System.exit(1);
	}
	if (buildPaths && !haveLabels) {
	    System.err.println("ERROR: to build graph paths you must specify samples and labels with -l");
	    System.exit(1);
	}
	if (catGraphs && (!haveNodes || !haveNodes2)) {
	    System.err.println("ERROR: to concatenate two graphs you must specify -nodes and -nodes2");
	    System.exit(1);
	}

        // our PangenomicGraph
        PangenomicGraph graph = new PangenomicGraph(cmd.getOptionValue("graph"));
        graph.setVerbose(cmd.hasOption("verbose"));

	// filters
	int maxCases = 0;
	double minMAF = 0.0;
	double maxMAF = 1.0;
	if (cmd.hasOption("maxcases")) maxCases = Integer.parseInt(cmd.getOptionValue("maxcases"));
	if (cmd.hasOption("minmaf")) minMAF = Double.parseDouble(cmd.getOptionValue("minmaf")) / 100.0;
	if (cmd.hasOption("maxmaf")) maxMAF = Double.parseDouble(cmd.getOptionValue("maxmaf")) / 100.0;
	boolean equalizeCasesControls = cmd.hasOption("equalizecasescontrols");

	if (buildPaths) {
	    if (haveNodes) {
		// load nodes from nodes.txt file
		graph.loadNodesFromTXT(new File(cmd.getOptionValue("nodesfile")));
		if (havePaths) {
		    // load the paths.txt file without any filtering
		    graph.loadPathsFromTXT(new File(cmd.getOptionValue("pathsfile")), maxCases, equalizeCasesControls);
		} else if (haveVCF) {
		    // build the graph paths from a VCF
		    graph.loadPathsFromVCF(new File(cmd.getOptionValue("vcffile")), new File(cmd.getOptionValue("labelsfile")), maxCases, equalizeCasesControls);
		} else if (haveList) {
		    // build the graph paths from a plink -list file
		    graph.loadPathsFromList(new File(cmd.getOptionValue("listfile")), new File(cmd.getOptionValue("labelsfile")), maxCases, equalizeCasesControls);
		}
	    } else if (haveVCF) {
		// load relevant nodes and paths from a tabix-indexed vcf.gz file
		graph.loadNodesFromVCF(new File(cmd.getOptionValue("vcffile")), minMAF, maxMAF);
		graph.loadPathsFromVCF(new File(cmd.getOptionValue("vcffile")), new File(cmd.getOptionValue("labelsfile")), maxCases, equalizeCasesControls);
	    } else if (haveList) {
		// load relevant nodes and paths from a plink -list file
		graph.loadNodesFromList(new File(cmd.getOptionValue("listfile")), minMAF, maxMAF); 
		graph.loadPathsFromList(new File(cmd.getOptionValue("listfile")), new File(cmd.getOptionValue("labelsfile")), maxCases, equalizeCasesControls);
	    }
	    graph.tallyLabelCounts();
	    System.err.println("Graph has "+graph.vertexSet().size()+" nodes, "+
			       graph.paths.size()+" paths, and "+graph.edgeSet().size()+" edges with "+
			       graph.labelCounts.get("case")+"/"+graph.labelCounts.get("ctrl")+" cases/controls");
	} else if (buildNodes) {
	    if (haveNodes) {
		// load the nodes from nodes.txt file
		graph.loadNodesFromTXT(new File(cmd.getOptionValue("nodesfile")));
	    } else if (haveVCF) {
		// load relevant nodes from a tabix-indexed vcf.gz file
		graph.loadNodesFromVCF(new File(cmd.getOptionValue("vcffile")), minMAF, maxMAF);
	    } else if (haveList) {
		// load relevant nodes from a plink -list file
		graph.loadNodesFromList(new File(cmd.getOptionValue("listfile")), minMAF, maxMAF);
	    }
	} else if (catGraphs) {
	    // load the first graph's nodes
	    graph.loadNodesFromTXT(new File(cmd.getOptionValue("nodesfile")));
	    // append the second graph's nodes
	    graph.appendNodesFromTXT(new File(cmd.getOptionValue("nodes2file")));
	}

	// output
	if (!cmd.hasOption("nodesfile") && graph.getNodes().size()>0) {
	    // to graph.nodes.txt
	    if (graph.verbose) System.err.println("Writing "+graph.getNodesFilename());
	    graph.printNodes(new PrintStream(graph.getNodesFilename()));
	}
	if (catGraphs) {
	    // to graph.nodes.txt
	    if (graph.verbose) System.err.println("Writing "+graph.getNodesFilename());
	    graph.printNodes(new PrintStream(graph.getNodesFilename()));
	}	    
	if (!cmd.hasOption("pathsfile") && graph.paths.size()>0) {
	    // to conglomerate paths filename
	    String pathsFilename = graph.getPathsFilename()+"."+cmd.getOptionValue("labelsfile");
	    if (graph.verbose) System.err.println("Writing "+pathsFilename);
	    graph.printPaths(new PrintStream(pathsFilename));
	}
    }

    /**
     * Return the name of the nodes.txt file.
     */
    public String getNodesFilename() {
	return name+".nodes.txt";
    }

    /**
     * Return the name of the paths.txt file.
     */
    public String getPathsFilename() {
	return name+".paths.txt";
    }

    /**
     * Return the nodes.txt file.
     */
    public File getNodesFile() {
	return new File(getNodesFilename());
    }

    /**
     * Return the paths.txt file.
     */
    public File getPathsFile() {
	return new File(getPathsFilename());
    }

    /**
     * Set the verbosity flag.
     */
    public void setVerbose(boolean flag) {
	verbose = flag;
    }

    /**
     * Terminates with an error message if nodeIdMap is empty.
     */
    void checkNodeIdMap() {
	if (nodeIdMap.size()==0) {
	    System.err.println("ERROR: PangenomicGraph.nodeIdMap is empty. You must load nodeIdMap before loading paths.");
	    System.exit(1);
	}
    }

    /**
     * Terminates with an error message if nodeKeyMap is empty.
     */
    void checkNodeKeyMap() {
	if (nodeKeyMap.size()==0) {
	    System.err.println("ERROR: PangenomicGraph.nodeKeyMap is empty. You must load nodeKeyMap before loading paths from this source.");
	    System.exit(1);
	}
    }
}
